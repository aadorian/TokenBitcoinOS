# Detailed Build Commands Explanation

## Building Your Charms Application

When building a Charms application, you'll typically use these two commands:

```bash
cargo update
app_bin=$(charms app build)
```

## `cargo update`

This command updates all dependencies in your Rust project to their latest compatible versions.

### What it does:
- Reads the `Cargo.toml` file which specifies dependency version requirements
- Checks crates.io (Rust's package registry) for the newest versions that match those requirements
- Updates the `Cargo.lock` file with the specific versions to use
- Ensures all dependencies are compatible with each other
- Does NOT change the version requirements in `Cargo.toml`, only updates within the specified ranges

### Example:
If `Cargo.toml` specifies `serde = "1.0"`, cargo update will fetch the latest 1.x version (like 1.0.210) but won't upgrade to 2.0.

### Why it's important:
- Gets the latest bug fixes and security patches
- Ensures reproducible builds through the `Cargo.lock` file
- Maintains compatibility with your specified version constraints

## `app_bin=$(charms app build)`

This is a shell command that performs two operations:

### 1. `charms app build` - Builds your Charms application

**What it does:**
- Compiles the Rust code to WebAssembly (Wasm) format
- Uses the `wasm32-wasip1` target (WebAssembly System Interface Preview 1)
- Applies release optimizations defined in `Cargo.toml`:
  - **LTO (Link Time Optimization)**: `lto = "fat"` - Optimizes across all crates
  - **Codegen units**: `codegen-units = 1` - Better optimization at cost of compile time
  - **Strip symbols**: `strip = "symbols"` - Removes debugging symbols to reduce size
  - **Panic behavior**: `panic = "abort"` - Aborts on panic instead of unwinding
- Outputs the binary to `./target/wasm32-wasip1/release/my-token.wasm`
- Returns the full path to the compiled Wasm binary

### 2. `app_bin=$(...)` - Captures the output

**What it does:**
- Stores the path to the compiled Wasm binary in the `app_bin` shell variable
- Allows you to use `$app_bin` in subsequent commands without retyping the path
- Makes your build scripts more maintainable and less error-prone

### Usage examples:

```bash
# Get the verification key for your app
charms app vk $app_bin

# Use in spell checking
charms spell check --app-bins=${app_bin}

# Multiple apps can be stored in different variables
app_bin_1=$(cd project1 && charms app build)
app_bin_2=$(cd project2 && charms app build)
```

## Complete Build Workflow

Here's the typical workflow when developing a Charms application:

```bash
# 1. Navigate to your project directory
cd my-token

# 2. Ensure you have the WebAssembly target installed (first time only)
rustup target add wasm32-wasip1

# 3. Update dependencies to latest compatible versions
cargo update

# 4. Build the application and store the binary path
app_bin=$(charms app build)

# 5. Get the verification key for your app
export app_vk=$(charms app vk $app_bin)

# 6. Now you can use $app_bin and $app_vk in your spells and tests
```

## Output Location

After building, your compiled Wasm binary will be located at:
```
./target/wasm32-wasip1/release/my-token.wasm
```

This binary:
- Is optimized for production use
- Contains your complete application logic
- Can be verified using the verification key
- Is used when executing spells and transactions

## Why WebAssembly (Wasm)?

Charms uses WebAssembly because it provides:
- **Deterministic execution**: Same code produces same results everywhere
- **Sandboxed environment**: Secure execution isolation
- **Platform independence**: Runs on any system with a Wasm runtime
- **Efficient verification**: Cryptographic proofs of correct execution
- **Small binary sizes**: Optimized builds are compact and fast to distribute

## Environment Variables for Spells (envsubst)

When working with Charms spells (YAML transaction files), you'll use the `envsubst` command to substitute environment variables into the spell templates. Here are all the variables used across the spell files:

### Required Variables

#### Application Variables
- **`app_id`** - Application identifier (derived from input UTXO)
  ```bash
  export app_id=$(echo -n "${in_utxo_0}" | sha256sum | cut -d' ' -f1)
  ```
  - Generated by hashing the first input UTXO
  - Uniquely identifies your application instance

- **`app_vk`** - Application verification key
  ```bash
  export app_vk=$(charms app vk $app_bin)
  ```
  - Cryptographic hash of your compiled Wasm binary
  - Used to verify the application's integrity

#### Input UTXOs
- **`in_utxo_0`** - First input UTXO (for creating the NFT)
  ```bash
  export in_utxo_0="d8fa4cdade7ac3dff64047dc73b58591ebe638579881b200d4fea68fc84521f0:0"
  ```
  - Format: `transaction_hash:output_index`
  - Use `bitcoin-cli listunspent` or equivalent to find available UTXOs

- **`in_utxo_1`** - Second input UTXO (for minting tokens or sending)
  ```bash
  export in_utxo_1="your_utxo_hash:index"
  ```

#### Bitcoin Addresses
- **`addr_0`** - First destination address (receives NFT in mint-nft.yaml)
  ```bash
  export addr_0="tb1p3w06fgh64axkj3uphn4t258ehweccm367vkdhkvz8qzdagjctm8qaw2xyv"
  ```

- **`addr_1`** - Second destination address (receives minted tokens)
  ```bash
  export addr_1="your_bitcoin_address"
  ```

- **`addr_2`** - Third destination address (receives NFT with updated state)
  ```bash
  export addr_2="your_bitcoin_address"
  ```

- **`addr_3`** - Fourth destination address (receives tokens in send.yaml)
  ```bash
  export addr_3="your_bitcoin_address"
  ```

- **`addr_4`** - Fifth destination address (receives change in send.yaml)
  ```bash
  export addr_4="your_bitcoin_address"
  ```

### Variables by Spell File

#### mint-nft.yaml
Creates the initial reference NFT that controls token minting.

**Required variables:**
- `app_id` - Application identifier
- `app_vk` - Verification key
- `in_utxo_0` - Input UTXO to be spent
- `addr_0` - Destination address for the NFT

**Example usage:**
```bash
export app_vk=$(charms app vk $app_bin)
export in_utxo_0="your_utxo:0"
export app_id=$(echo -n "${in_utxo_0}" | sha256sum | cut -d' ' -f1)
export addr_0="your_address"

cat ./spells/mint-nft.yaml | envsubst | charms spell check --prev-txs=${prev_txs} --app-bins=${app_bin}
```

#### mint-token.yaml
Mints fungible tokens from the reference NFT.

**Required variables:**
- `app_id` - Application identifier
- `app_vk` - Verification key
- `in_utxo_1` - The NFT UTXO being spent
- `addr_1` - Address to receive minted tokens
- `addr_2` - Address to receive NFT with updated remaining supply

#### send.yaml
Transfers fungible tokens between addresses.

**Required variables:**
- `app_id` - Application identifier
- `app_vk` - Verification key
- `in_utxo_1` - Token UTXO being spent
- `addr_3` - First recipient address
- `addr_4` - Second recipient address (change)

### Complete Example Workflow

```bash
# 1. Build the application
cd my-token
cargo update
app_bin=$(charms app build)

# 2. Get the verification key
export app_vk=$(charms app vk $app_bin)

# 3. Set up your input UTXO (get this from your Bitcoin wallet)
export in_utxo_0="d8fa4cdade7ac3dff64047dc73b58591ebe638579881b200d4fea68fc84521f0:0"

# 4. Generate the app_id from the input UTXO
export app_id=$(echo -n "${in_utxo_0}" | sha256sum | cut -d' ' -f1)

# 5. Set your destination address
export addr_0="tb1p3w06fgh64axkj3uphn4t258ehweccm367vkdhkvz8qzdagjctm8qaw2xyv"

# 6. Set the previous transaction data
prev_txs=02000000000101a3a4c09a03f771e863517b8169ad6c08784d419e6421015e8c360db5231871eb0200000000fdffffff024331070000000000160014555a971f96c15bd5ef181a140138e3d3c960d6e1204e0000000000002251207c4bb238ab772a2000906f3958ca5f15d3a80d563f17eb4123c5b7c135b128dc0140e3d5a2a8c658ea8a47de425f1d45e429fbd84e68d9f3c7ff9cd36f1968260fa558fe15c39ac2c0096fe076b707625e1ae129e642a53081b177294251b002ddf600000000

# 7. Process the spell with envsubst and check it
cat ./spells/mint-nft.yaml | envsubst | charms spell check --prev-txs=${prev_txs} --app-bins=${app_bin}
```

### Understanding the envsubst Command

The `envsubst` command substitutes environment variables in the YAML template:

```bash
cat ./spells/mint-nft.yaml | envsubst
```

**Before envsubst:**
```yaml
apps:
  $00: n/${app_id}/${app_vk}
ins:
  - utxo_id: ${in_utxo_0}
outs:
  - address: ${addr_0}
```

**After envsubst:**
```yaml
apps:
  $00: n/a1b2c3d4.../92d262609cf460878f401be9f342bcfa...
ins:
  - utxo_id: d8fa4cdade7ac3dff64047dc73b58591ebe638579881b200d4fea68fc84521f0:0
outs:
  - address: tb1p3w06fgh64axkj3uphn4t258ehweccm367vkdhkvz8qzdagjctm8qaw2xyv
```

This allows you to create reusable spell templates and customize them for each transaction by setting environment variables.
